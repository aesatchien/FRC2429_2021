import math
import wpilib.kinematics
import wpimath.geometry as geo
import wpimath
import wpilib.controller
from wpimath.trajectory.constraint import DifferentialDriveVoltageConstraint
from pathlib import Path

# drivetrain constants
wheel_diameter_in = 8  # wheel diameter in inches
wheel_diameter_m = 8 * 0.0254  # wheel diameter in inches

# Configure encoders and controllers
# should be wheel_diameter * pi / gear_ratio - and for the old double reduction gear box the gear ratio was 4.17:1.
# With the shifter (low gear) I think it was a 12.26.  Then new 2020 WCD gearbox is 9.52, and the tuffbox is 12.75
gear_ratio = 9.52
sparkmax_conversion_factor_inches = wheel_diameter_in * math.pi / gear_ratio
sparkmax_conversion_factor_meters = wheel_diameter_m * math.pi / gear_ratio

# pretend encoders for simulation
encoder_CPR = 1024 # encoder counts per revolution
# encoder_distance_per_pulse_m = wheel_diameter_m * math.pi / (encoder_CPR * gear_ratio)
encoder_distance_per_pulse_m = wheel_diameter_m * math.pi / (encoder_CPR )

# set up the wpilib kinematics model
track_width_meters = 0.69
drive_kinematics = wpilib.kinematics.DifferentialDriveKinematics(track_width_meters)

# get these from robot characterization tools - using simulated values for now
# ToDo: characterize this on the real robot
ks_volts = 1.14 # determined as the minimum to start the simulation robot moving, or -b/m (vel=0 of the vel=mV+b)
kv_volt_seconds_per_meter = 2.15  # determined as 1/slope of the vel vs volts equation
ka_volt_seconds_squared_per_meter = 0.0  # not sure if we have one in our sim or how to calculate it
kp_drive_vel = 0.0  # this is kp for the PID on each side on top of the feed forward (i think)

# constants for autonomous THIS CONTROLS THE SPEEDS OF THE TRAJECTORIES GENERATED BY THIS PROGRAM
k_max_speed_meters_per_second = 0.75  # pretty reasonable for the sim
k_max_acceleration_meters_per_second_squared = 1 # get up to full speed this fast?

# Reasonable baseline values for a RAMSETE follower in units of meters and seconds
ramsete_B = 2  # default 2.  like a proportional, higher is more aggressive
ramsete_Zeta = 0.7  #  default 0.7.  like a damping term, needs to be between 0 and 1


# --------------  DRIVETRAIN OBJECTS FOR TRAJECTORy TRACKING  -------------

# Create a voltage constraint to ensure we don't accelerate too fast
feed_forward = wpilib.controller.SimpleMotorFeedforwardMeters(ks_volts, kv_volt_seconds_per_meter, ka_volt_seconds_squared_per_meter)
autonomous_voltage_constraint = DifferentialDriveVoltageConstraint(feed_forward, drive_kinematics, 10)

# Create config for trajectories
config = wpimath.trajectory.TrajectoryConfig(k_max_speed_meters_per_second, k_max_acceleration_meters_per_second_squared)
config.setKinematics(drive_kinematics)
config.addConstraint(autonomous_voltage_constraint)


# --------------  SAMPLE TRAJECTORIES  -------------


# example trajectory to test
def get_test_directory():
    start_pose = geo.Pose2d(0, 0, geo.Rotation2d(0))
    end_pose = geo.Pose2d(3, 0, geo.Rotation2d(0))
    midpoints = [geo.Translation2d(1, 1), geo.Translation2d(2, -1)]
    test_trajectory = wpimath.trajectory.TrajectoryGenerator.generateTrajectory(start_pose, midpoints, end_pose, config)
    return test_trajectory

# minimum slalom test - nice thing about having the points means you can change the speeds for the
# trajectory config and then you can go faster and faster.  but it's better to use the pathweaver once you have the speeds you want
def get_point_trajectory():
    start_pose = geo.Pose2d(0, 0, geo.Rotation2d(0))
    end_pose = geo.Pose2d(0, 1.7, geo.Rotation2d(3.14))
    midpoints = [geo.Translation2d(0.32, 0.01), geo.Translation2d(1.25, 0.47), geo.Translation2d(2.16, 1.71),
                    geo.Translation2d(4.74, 1.91), geo.Translation2d(5.74, 1.06), geo.Translation2d(6.06, 0.31),
                    geo.Translation2d(7.41, 0.21), geo.Translation2d(7.52, 1.50), geo.Translation2d(6.97, 1.82),
                    geo.Translation2d(6.10, 1.48), geo.Translation2d(5.87, 0.84), geo.Translation2d(5.30, 0.17),
                    geo.Translation2d(3.77, -0.05), geo.Translation2d(1.81, 0.33), geo.Translation2d(1.12, 1.36),
                     geo.Translation2d(-0.15, 1.76)]
    slalom_point_trajectory = wpimath.trajectory.TrajectoryGenerator.generateTrajectory(start_pose, midpoints, end_pose, config)
    return slalom_point_trajectory

# just waypoints of poses - try a simple loop
def get_loop_trajectory():
    pose_points = [geo.Pose2d(0.09, 0.02, geo.Rotation2d(0.00)),
                    geo.Pose2d(6.17, 0.16, geo.Rotation2d(0.00)), geo.Pose2d(7.62, 0.87, geo.Rotation2d(1.60)),
                    geo.Pose2d(6.06, 1.75, geo.Rotation2d(3.14)), geo.Pose2d(0.21, 1.70, geo.Rotation2d(3.14))]
    loop_trajectory = wpimath.trajectory.TrajectoryGenerator.generateTrajectory(pose_points, config)
    return loop_trajectory

#lots of poses from above
def get_pose_trajectory():
    pose_points = [geo.Pose2d(0.32, 0.01, geo.Rotation2d(0.00)),
                        geo.Pose2d(1.25, 0.47, geo.Rotation2d(1.04)), geo.Pose2d(2.16, 1.71, geo.Rotation2d(0.69)),
                        geo.Pose2d(4.74, 1.91, geo.Rotation2d(0.00)), geo.Pose2d(5.74, 1.06, geo.Rotation2d(-1.21)),
                        geo.Pose2d(6.06, 0.31, geo.Rotation2d(0.00)), geo.Pose2d(7.41, 0.21, geo.Rotation2d(0.64)),
                        geo.Pose2d(7.52, 1.50, geo.Rotation2d(2.30)), geo.Pose2d(6.97, 1.82, geo.Rotation2d(3.12)),
                        geo.Pose2d(6.10, 1.48, geo.Rotation2d(-2.05)), geo.Pose2d(5.87, 0.84, geo.Rotation2d(-2.04)),
                        geo.Pose2d(5.30, 0.17, geo.Rotation2d(-2.55)), geo.Pose2d(3.77, -0.05, geo.Rotation2d(3.12)),
                        geo.Pose2d(1.81, 0.33, geo.Rotation2d(2.38)), geo.Pose2d(1.12, 1.36, geo.Rotation2d(2.30)),
                        geo.Pose2d(0.22, 1.69, geo.Rotation2d(-3.14)), geo.Pose2d(-0.15, 1.76, geo.Rotation2d(3.14))]
    pose_trajectory = wpimath.trajectory.TrajectoryGenerator.generateTrajectory(pose_points, config)
    return pose_trajectory

# alternately, import a pathweaver json
# https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/pathweaver/integrating-robot-program.html#importing-a-pathweaver-json

course = 'slalom'
def get_pathweaver_trajectory():
    #start_pose = geo.Pose2d(1.23, 0, geo.Rotation2d(0))  # just slalom for now
    trajectory_json = course + '.wpilib.json'
    trajectory_dir = 'output'
    try:
        trajectory_path = Path.cwd() / trajectory_dir / trajectory_json
        pathweaver_trajectory = wpimath.trajectory.TrajectoryUtil.fromPathweaverJson(str(trajectory_path))
        print(f"*** Successfully loaded: {trajectory_path} ***")
    except Exception as ex:
        print(f"*** Unable to open trajectory: {trajectory_path} ***")
        pathweaver_trajectory = None
    return pathweaver_trajectory